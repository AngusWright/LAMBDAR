crop_im <-
function(ra0=-999,dec0=-999,pathroot="",inpim=NA,cutrad=1,fitsoutname=NA, echo=FALSE){
    # Procedure takes a fits image and produces a new  
    # image, cropped to a region <cutrad> in diameter 
    # and centered around ra0 dec0
    # All inputs can be vectorised to length 'n', such that the output
    # will be a series of 'n' images whose names are the n 
    # dimensions of <fitsoutname>
    # NB:
    #   > ra0, dec0,fitsoutname must be of the same dimension  
    #   > If ra0, dec0, and fitsoutname have dimension > 0, and
    #     if cutrad, pathroot, inpim are of dimension 0, then 
    #     all ra0,dec0,fitsoutname are given the same cutrad, 
    #     pathroot, and inpim
    #   > If not supplied, cutrad == 1deg, pathroot==""
    #   > If not supplied, ra0 and dec0 will be set to 
    #   > the Image Centre
    
    cat(paste("   Cropping Image",inpim,"   "))
    # Ensure ra0, dec0, and fitsoutname have same dimensions
    if (ra0!=-999) { len<-length(ra0) } else { len<-length(inpim) } # Length is determined by ra0 vec or inpim vec
    if (((length(dec0       )-len)!=0)|                        # Must be exactly the same length
        ((length(fitsoutname)-len)!=0)|                        # Must be exactly the same length
       (((length(cutrad     )-len)!=0)&(length(cutrad  )!=1))| # Must be exactly the same length or 1
       (((length(pathroot   )-len)!=0)&(length(pathroot)!=1))| # Must be exactly the same length or 1
       (((length(inpim      )-len)!=0)&(length(inpim   )!=1))) # Must be exactly the same length or 1
    { stop("Mismatched Vector Dimensions in Inputs") }
     
    # Check Other input dimensions
    if (len>1) {
      if (length(ra0     )==1) { pathroot<-replicate(len, ra0     ) }
      if (length(dec0    )==1) { pathroot<-replicate(len, dec0    ) }
      if (length(pathroot)==1) { pathroot<-replicate(len, pathroot) }
      if (length(cutrad  )==1) { cutrad  <-replicate(len, cutrad  ) }
      if (length(inpim   )==1) { inpim   <-replicate(len, inpim   ) }
    }  
    
    # For Diagnostic - print final command instead of performing it
    if (echo) { echo<-"echo " } else { echo<-"" }

    # File definitions
    image <- paste(pathroot, inpim, sep="")
        
    # Setup Arrays
    xcen<-array(NA, len)
    ycen<-array(NA, len)
    naxis1<-array(NA, len)
    naxis2<-array(NA, len)
    pixsize<-array(NA, len)
    size<-array(NA, len)
    type<-array(NA, len)
    signed<-array(NA, len)
    headbytes<-array(NA, len)
    # Get header values
    for (i in 1:len) {
      astr_struc<-read.astr(image[i])
      naxis1[i]<-astr_struc$NAXIS[1]
      naxis2[i]<-astr_struc$NAXIS[2]
      pixsize[i]<-astr_struc$CD[1,1]
      # If needed, set ra0 and dec0
      if (ra0[i] ==-999) { ra0[i] <-as.numeric(astr_struc$CRVAL[1]) }
      if (dec0[i]==-999) { dec0[i]<-as.numeric(astr_struc$CRVAL[2]) }
      # Calculate pixel positions
      pixpos <- ad2xy(ra0[i],dec0[i],astr_struc)
      xcen[i] <- pixpos[,"X"]
      ycen[i] <- pixpos[,"Y"]
      # Get data precision type
      switch(astr_struc$BITPIX, "-64" = {
          size[i] = 8           # 64-bit float (double)
          type[i] = 'numeric'
          signed[i]=TRUE
      }, "-32" = {
          size[i] = 4           # 32-bit float (single)
          type[i] = 'numeric'
          signed[i]=TRUE
      }, "32" = {
          size[i] = 4           # 32-bit signed int (double)
          type[i] = 'integer'
          signed[i]=TRUE
      }, "16" = {
          size[i] = 2           # 16-bit signed int (single)
          type[i] = 'integer'
          signed[i]=TRUE
      }, "8" = {
          size[i] = 1           # 8-bit unsigned int
          type[i] = 'integer'
          signed[i]=FALSE
      }, stop("Unknown BITPIX request in .read.fits.image"))
    }
    # Check that cutrad is sensible
    if (cutrad < 0 ) { 
      warning("Cut Radius is < 0. Using 1deg radius instead")
      cutrad <- 1 
    }

    # Define lower and upper limits (make sure the limits 
    # are within the image)
    cutradpix <- abs((cutrad/pixsize))
    lowerx <- max(floor(xcen-cutradpix),replicate(len,1))
    upperx <- min(floor(xcen+cutradpix),naxis1)
    ncol<-upperx-lowerx+1
    lowery <- max(floor(ycen-cutradpix),replicate(len,1))
    uppery <- min(floor(ycen+cutradpix),naxis2)
    nrow<-uppery-lowery+1
    cutxcen <- abs(cutrad/pixsize)+1.5
    cutycen <- abs(cutrad/pixsize)+1.5
    
    ##Crop Image(s)
    # For every subimage wanted:
    #var<-foreach (inpim=inpim,lowerx=lowerx,lowery=lowery,signed=signed,type=type,size=size,naxis1=naxis1,naxis2=naxis2,
    #              nrow=nrow,ncol=ncol,fitsoutname=fitsoutname) %do% {
    for (i in 1:len) {
      pipe<-file(inpim[i], 'rb')
      nlines<-length(read.fitshdr(inpim[i])[,1])
      mult=ceiling(nlines/36)
      headbytes<-nchar(readChar(pipe,mult*36*80), type='bytes')
      # Use seek to get to the start of the subimage
      imstrt=naxis1[i]*(lowery[i]-1)+lowerx[i]-1
      seek(pipe, where=headbytes+(imstrt)*size[i],origin='start')
    
      # Read the subimage with readBin, read each row, then go to the start 
      # of the next row
      subim<-NULL
      for (j in 1:nrow[i]){
        #subim<-c(subim, readBin(pipe,type[i],n=ncol[i],size[i],signed=signed[i],endian='big'))
        seek(pipe, where=(naxis1[i]-ncol[i])*size[i], origin='current')
      }
      #subim<-foreach (j=1:nrow, combine='c') %do%{
      #  val<-readBin(pipe,type,n=ncol,size,signed=signed,endian='big')
      #  seek(pipe, where=(naxis1-ncol)*size, origin='current')
      #  return(val)
      #}
      subim<-array(subim, dim=c(nrow[i],ncol[i]))

      # Output the subimage to file - with appropriate header values
      header<-read.fitshdr(inpim[i])
      # New header vals
      header[which(header[,'key']=='NAXIS1'),'value']<-paste(ncol[i])
      header[which(header[,'key']=='NAXIS2'),'value']<-paste(nrow[i])
      header[which(header[,'key']=='CRVAL1'),'value']<-paste(ra0[i])
      header[which(header[,'key']=='CRVAL2'),'value']<-paste(dec0[i])
      header[which(header[,'key']=='CRPIX1'),'value']<-paste(cutxcen[i])
      header[which(header[,'key']=='CRPIX2'),'value']<-paste(cutycen[i])
      write.fits(list(hdr=list(header),dat=list(subim)), file=fitsoutname[i])
      close(pipe)
    }


    # Crop Image(s)
    #if(file.exists(fitsoutname)){file.remove(fitsoutname)}
    #cutcommandim <- paste(echo,"fitscopy ",image,"[",format(lowerx,scientific=FALSE),":",format(upperx,scientific=FALSE),",",format(lowery,scientific=FALSE),":",
    #format(uppery,scientific=FALSE),"] ",fitsoutname,sep="", collape=" ; ")
    #timer=system.time(system(cutcommandim))

    cat(" - Done\n") 


}

read.astr <-
function(fitsname){
  # Proceedure Reads the header of <fitsname> and 
  # Returns the astrometry structure

  #Initialise List
  astr_struc<-NULL
  #Check for Typical Keywords of known Lengths
  astr_struc<-c(astr_struc, list(BITPIX  =read.fitskey("BITPIX",fitsname)))
  astr_struc<-c(astr_struc, list(NAXIS   =as.numeric(c(read.fitskey(c("NAXIS1","NAXIS2"),fitsname)))))
  astr_struc<-c(astr_struc, list(PC      =as.numeric(c(read.fitskey(c("PC1_1","PC1_2"),fitsname)))))
  astr_struc<-c(astr_struc, list(CDELT   =as.numeric(c(read.fitskey(c("CDELT1","CDELT2"),fitsname)))))
  astr_struc<-c(astr_struc, list(CRPIX   =as.numeric(c(read.fitskey(c("CRPIX1","CRPIX2"),fitsname))))) 
  astr_struc<-c(astr_struc, list(CRVAL   =as.numeric(c(read.fitskey(c("CRVAL1","CRVAL2"),fitsname)))))
  astr_struc<-c(astr_struc, list(CD=rbind(as.numeric(c(read.fitskey(c("CD1_1","CD1_2"),fitsname))),
                                          as.numeric(c(read.fitskey(c("CD2_1","CD2_2"),fitsname))))))
  astr_struc<-c(astr_struc, list(CROTA   =as.numeric(c(read.fitskey(c("CROTA1","CROTA2"),fitsname))))) 
  astr_struc<-c(astr_struc, list(LONGPOLE=as.numeric(c(read.fitskey("LONGPOLE",fitsname))))) 
  astr_struc<-c(astr_struc, list(LATPOLE=as.numeric(c(read.fitskey("LATPOLE",fitsname)))))
  # Check for PV2 Keywords (can be up to 21)
  if ((is.finite(read.fitskey("PV2_1",fitsname)))) { 
    PV2<-foreach (i=1:21, .combine="cbind") %do% {
      as.numeric(read.fitskey(paste("PV2_",i,sep=""),fitsname))
    }
    PV2<-PV2[which(is.finite(PV2))]
    astr_struc<-c(astr_struc, list(PV2=PV2))

  }
  #Convert to standard Format -> use CD matrix
  if (!is.finite(astr_struc$CD[1,1])) { 
  astr_struc$CD<-rbind(as.numeric(c(astr_struc$CDELT[1],astr_struc$CROTA[1])),
                       as.numeric(c(astr_struc$CROTA[2],astr_struc$CDELT[2])))
  }
  #Remove NA elements 
  #astr_struc<-astr_struc[!sapply(astr_struc, is.na)] # If CROTA[2] is missing, this could be bad... Better to leave as NULL?

  return(astr_struc)
}

opencatalogue <-
function(catalogue){
  #Open and Read Catalogue

  #Test Read of Catalogue for errors
  error<-try(as.data.frame(read.csv(catalogue)))
  if (class(error)=="try error") {
    stop("Catalogue File read failed")
  }
  #Read Fits Table
  fitstable<-as.data.frame(read.csv(catalogue))
  nrows<-length(fitstable[,1])
  #Check for Correct Column Syntax & Read Data
  #GAMA Catalogue ID
  id_g<-fitstable[1:nrows,"CATAID"]
  if (is.null(id_g[1])) { 
    stop("Catalogue does not contain CATAID column")
  }
  #Object RA
  ra_g<-fitstable[1:nrows,"RA"]
  if (is.null(ra_g[1])) { 
    stop("Catalogue does not contain RA column")
  }
  #Object Dec
  dec_g<-fitstable[1:nrows,"DEC"]
  if (is.null(dec_g[1])) { 
    stop("Catalogue does not contain DEC column")
  }
  return(list(CATAID=id_g, RA=ra_g, DEC=dec_g))
}

radec2xy <-
function(ra,dec,ra0=0,dec0=0,x0=0,y0=0,xscale=1,yscale=1){
# Converts RA/DEC (degrees) to x/y (pixels) position using the TAN Gnomonic projection system
# point of interest RA & DEC, anchor point RA & DEC, anchor point x & y, x & y scale (degrees per pixel)
# FROM: http://mathworld.wolfram.com/GnomonicProjection.html
  ra0=ra0*(pi/180)
  dec0=dec0*(pi/180)
  ra=ra*(pi/180)
  dec=dec*(pi/180)
  xscale=xscale*(pi/180)
  yscale=yscale*(pi/180)
  xx = function(ra0,dec0,ra,dec){
          (cos(dec)*sin(ra-ra0))/(sin(dec0)*sin(dec)+(cos(dec0)*cos(dec)*cos(ra-ra0)))
  }
  yy = function(ra0,dec0,ra,dec){
          ((cos(dec0)*sin(dec))-(sin(dec0)*cos(dec)*cos(ra-ra0)))/(sin(dec0)*sin(dec)+(cos(dec0)*cos(dec)*cos(ra-ra0)))
  }
  X = (xx(ra0,dec0,ra,dec)/tan(xscale)) + x0
  Y = (yy(ra0,dec0,ra,dec)/tan(yscale)) + y0
  return(cbind(X,Y))
}

ad2xy <-
function(ra,dec,astr_struc,diagnostic=FALSE){
# Converts RA/DEC (degrees) to x/y (pixels) position using the TAN Gnomonic projection system
# point of interest RA & DEC, anchor point RA & DEC, anchor point x & y, x & y scale (degrees per pixel)
# FROM: http://mathworld.wolfram.com/GnomonicProjection.html
  ra0=astr_struc$CRVAL[1]
  dec0=astr_struc$CRVAL[2]
  x0=astr_struc$CRPIX[1]
  y0=astr_struc$CRPIX[2]
  xscale=astr_struc$CD[1,1]
  yscale=astr_struc$CD[2,2]
  if (diagnostic) { message(paste("ASTR:",ra0,dec0,x0,y0,xscale,yscale)) }
  pix<-radec2xy(ra,dec,ra0,dec0,x0,y0,xscale,yscale)
  return(pix)
}
