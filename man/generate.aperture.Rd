\name{generate.aperture}
\alias{generate.aperture}
\alias{checkgrid}
\alias{inap}
\alias{reexpand.grid}
%- Also NEED an `\alias' for EACH other topic documented here.
\title{
Elliptical Aperture Creation
}
\description{
The generate.aperture() procedure creates a single elliptical aperture on a finite grid, which is designated by the values of \{x,y\}.
The aperture is created with properties determined by the input parameters. In order to improve the accuracy of
the aperture integral, the accuracy of the pixel values at the aperture boundary are improved by increasing the
resolution of the grid at the boundary, calculating the subpixel values, and summing over subpixels.
The functions checkgrid(), inap(), and reexpand.grid() are low level functions called internally by generate.aperture().
}
\usage{
generate.aperture(x, y, xstep, ystep, xcen = 0, ycen = 0,
axrat = 1, axang = 0, majax = 1, deg = TRUE, resample.upres = 2,
resample.iterations = 9, pixscale = FALSE, peakscale = FALSE,
peak = 1)
checkgrid(x, y, xstep, ystep, xcen = 0, ycen = 0,
axrat = 1, axang = 0, majax = 1, deg = TRUE)
inap(x, y, xcen = 0, ycen = 0, axrat = 1, axang = 0,
majax = 1, deg = TRUE)
reexpand.grid(x, y, xstep, ystep, id, resample.upres = 2)
}
%- maybe also `usage' for other objects documented here.
\arguments{
  \item{x}{
numeric vector; The x coordinates associated with every point on the grid that the aperture will be placed upon
}
  \item{y}{
numeric vector; The y coordinates associated with every point on the grid that the aperture will be placed upon
}
  \item{xstep}{
numeric; The interval between each x coordinate
}
  \item{ystep}{
numeric; The interval between each y coordinate
}
  \item{xcen}{
numeric; x value that aperture will be centred on
}
  \item{ycen}{
numeric; y value that aperture will be centred on
}
  \item{axrat}{
numeric; ratio of minor-to-major axis of aperture: 0 < axrat < 1
}
  \item{axang}{
numeric; angle that the major axis makes with the y axis (i.e. N0E90)
}
  \item{majax}{
numeric; length of the major axis in pixels/grid-units
}
  \item{deg}{
character;
}
  \item{id}{
character; id of parent pixel
}
  \item{resample.upres}{
numeric; exponent used to increase resolution of boundary pixels. Must be > 1.
}
  \item{resample.iterations}{
numeric; number of iterations performed when increasing the resolution of boundary pixels.
         If resample.iterations=0, no increase in resolution of boundary pixels occurs.
}
  \item{pixscale}{
logical; if TRUE - values are scaled to reflect pixel area, rather than pixel fraction
         if FALSE - pixels are not scaled, and reflect piel fraction rather than area
}
  \item{peakscale}{
logical; if TRUE - aperture is scaled so that maximum pixel value is `peak'.
         if FALSE - aperture is normalised such that volume of aperture is equal to unity
}
  \item{peak}{
numeric; the value used to rescale the peak
}
}
\details{
The function, at its most rudimentary, creates an eliptical aperture on a pixel-grid. The input values to
the function are largely just the parameers needed to describe the eliptical aperture
we wish to generate. There are additional paramaters (resample.upres, resample.iterations, pixscale) that are
used specifically to improve the aperture generation for use in photometric measurements.

As the procedure is designed for use in high precision photometric measurements, the aperture integral can be
improved significantly by determining the values of the pixels at the boundary at high resolution. For this
reason, the function takes two inputs (resample.upres and resample.iterations) which increase the resolution of the boundary
pixels. After the last iteration, the resolution of pixels on the aperture boundary will be (resample.upres)^(resample.iterations)
higher than the original pixel size.
}
\value{
array; The procedure returns an array similar to that generated by the expanded.grid() function; it has dimension
       [n,3] where n is the number of points on the input grid. The three columns of this matrix are:
            1 - x coordinates of each point on the grid (i.e. same as the input variable `x')
            2 - y coordinates of each point on the grid (i.e. same as the input variable `y')
            3 - the pixel value corresponding to this x and y position
}
%%\references{
%% ~put references to the literature/web site here ~
%%}
\author{
Aaron Robotham{ ICRAR}
 {\email{aaron.robotham@icrar.org}}

Angus H Wright{ ICRAR}
 {\email{angus.wright@icrar.org}}
}
%%\note{
%%}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
\link{measure.fluxes}, \link{flux.measurements}
}
\examples{
## Example 1: Simple Placement of an aperture
#Generate a random grid radius
grid.width<-floor(runif(1)*100)
#Define a grid onto which we will place the aperture
grid<-expand.grid(seq(-grid.width,grid.width), seq(-grid.width,grid.width))
#Generate random elliptical aperture parameters
majax<-runif(1,min=0.2,max=0.8)*grid.width
axrat<-runif(1,min=0.2,max=1)
axang<-runif(1)*180
#Place the aperture using binary Placement
aper_expanded<-generate.aperture(x=grid[,1],y=grid[,2],xstep=1,ystep=1,
axrat=axrat,axang=axang,majax=majax,resample.iterations=-1)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(grid.width*2+1))
#Plot Aperture
layout(cbind(1,2,3,4))
image(x=seq(-grid.width,grid.width),y=seq(-grid.width,grid.width),z=aper,
xlab='X (pix)',ylab='Y (pix)',asp=1)

## Example 2: Quarternary Placement
#Place the aperture using quarternary Placement
aper_expanded<-generate.aperture(x=grid[,1],y=grid[,2],xstep=1,ystep=1,
axrat=axrat,axang=axang,majax=majax,resample.iterations=0)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(grid.width*2+1))
#Plot Aperture
image(x=seq(-grid.width,grid.width),y=seq(-grid.width,grid.width),z=aper,
xlab='X (pix)',ylab='Y (pix)',asp=1)

## Example 3: Improve aperture edge-pixel determination
#Using the same parameters as in Example 1, just improve edge determination
aper_expanded<-generate.aperture(x=grid[,1],y=grid[,2],xstep=1,ystep=1,
axrat=axrat,axang=axang,majax=majax, resample.upres=3, resample.iterations=4)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(grid.width*2+1))
#Plot Aperture
image(x=seq(-grid.width,grid.width),y=seq(-grid.width,grid.width),z=aper,
xlab='X (pix)',ylab='Y (pix)',asp=1)

## Example 3: Quantifying improvement of aperture integral
#Generate the grid
grid.width<-2
grid<-expand.grid(seq(-grid.width,grid.width,by=0.1),
seq(-grid.width,grid.width, by=0.1))
#Using a simple elliptical parameters, create basic aperture
aper_expanded<-generate.aperture(x=grid[,1],y=grid[,2],xstep=0.1,ystep=0.1,
axrat=0.5,axang=-45,majax=2,resample.iterations=0)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=length(seq(-grid.width,grid.width,by=0.1)))
#Plot Aperture
image(x=seq(-grid.width,grid.width,by=0.1),y=seq(-grid.width,grid.width,by=0.1),
z=aper,xlab='X (pix)',ylab='Y (pix)',asp=1)
#This aperture should integrate to 2pi, so we can use this to
#quantify the improvement of our integral by plotting the integral vs iteration
residual<-array(0,11)
for (i in 1:11) {
  aper_expanded<-generate.aperture(x=grid[,1],y=grid[,2],xstep=0.1,ystep=0.1,
  axrat=0.5,axang=-45,majax=2,resample.upres=2,resample.iterations=(i-1),pixscale=TRUE)
  residual[i]=abs(sum(aper_expanded[,3])-2*pi)
}
#Plot the residuals
magplot(x=seq(0,10), y=residual, xlab="Number of descent iterations",
ylab="Aper. Area - Expected Area",log='y',type='b')

}
% Add one or more standard keywords, see file `KEYWORDS' in the
% R documentation directory.
\keyword{ Aperture }
%\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
