\name{iterapint}
\alias{iterapint}
\alias{checkgrid}
\alias{inap}
\alias{reexpand.grid}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Elliptical Aperture Creation
}
\description{
The iterapint() procedure creates a single elliptical aperture on a finite grid, which is designated by the values of \{x,y\}.
The aperture is created with properties determined by the input parameters. In order to improve the accuracy of
the aperture integral, the accuracy of the pixel values at the aperture boundary are improved by increasing the
resolution of the grid at the boundary, calculating the subpixel values, and summing over subpixels.
The functions checkgrid(), inap(), and reexpand.grid() are low level functions called internally by iterapint().
}
\usage{
iterapint(x, y, xstep, ystep, xcen = 0, ycen = 0, axrat = 1, axang = 0, majax = 1, deg = T, upres = 2, itersteps = 10, pixscale = FALSE, splitpart = TRUE)
checkgrid(x, y, xstep, ystep, xcen = 0, ycen = 0, axrat = 1, axang = 0, majax = 1, deg = T)
inap(x, y, xcen = 0, ycen = 0, axrat = 1, axang = 0, majax = 1, deg = T)
reexpand.grid(x, y, xstep, ystep, id, upres = 2)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{x}{
numeric vector; The x coordinates associated with every point on the grid that the aperture will be placed upon
}
  \item{y}{
numeric vector; The y coordinates associated with every point on the grid that the aperture will be placed upon
}
  \item{xstep}{
numeric; The interval between each x coordinate
}
  \item{ystep}{
numeric; The interval between each y coordinate
}
  \item{xcen}{
numeric; x value that aperture will be centred on
}
  \item{ycen}{
numeric; y value that aperture will be centred on
}
  \item{axrat}{
numeric; ratio of minor-to-major axis of aperture: 0 < axrat < 1
}
  \item{axang}{
numeric; angle that the major axis makes with the y axis (i.e. N0E90)
}
  \item{majax}{
numeric; length of the major axis in pixels/grid-units
}
  \item{deg}{
character;
}
  \item{upres}{
numeric; exponent used to increase resolution of boundary pixels. Must be > 1.
}
  \item{itersteps}{
numeric; number of iterations performed when increasing the resolution of boundary pixels.
         If itersteps=0, no increase in resolution of boundary pixels occurs.
}
  \item{pixscale}{
logical; if TRUE - aperture is scaled so that maximum pixel value is unity.
         if FALSE - aperture is normalised such that volume of aperture is equal to unity
}
  \item{splitpart}{
logical; determines how aperture boundary pixels that are partially covered by the aperture are assigned.
         if TRUE  - boundary pixels are assigned fractional values determined by the number of corners that
                    the pixel has covered by the aperture.
         if FALSE - boundary pixels are assigned unity if the pixel centre is covered, otherwise zero.
}
}
\details{
The function, at its most rudimentary, creates an eliptical aperture on a pixel-grid. The input values to
the function are largely just the parameers needed to describe the eliptical aperture
we wish to generate. There are additional paramters (upres, itersteps, pixscale, splitpart) that are
used specifically to improve the aperture generation for use in photometric measurements.

As the procedure is designed for use in high precision photometric measurements, the aperture integral can be
improved significantly by determining the values of the pixels at the boundary at high resolution. For this
reason, the function takes two inputs (upres and itersteps) which increase the resolution of the boundary
pixels. After the last iteration, the resolution of pixels on the aperture boundary will be (upres)^(itersteps)
higher than the original pixel size.
}
\value{
array; The procedure returns an array similar to that generated by the expanded.grid() function; it has dimension
       [n,3] where n is the number of points on the input grid. The three columns of this matrix are:
            1 - x coordinates of each point on the grid (i.e. same as the input variable 'x')
            2 - y coordinates of each point on the grid (i.e. same as the input variable 'y')
            3 - the pixel value corresponding to this x and y position
}
%%\references{
%% ~put references to the literature/web site here ~
%%}
\author{
Aaron Robotham{ ICRAR}
 {\email{aaron.robotham@icrar.org}};
Angus H Wright{ ICRAR}
 {\email{angus.wright@icrar.org}}
}
%%\note{
%%}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
\link{MeasureFluxes}, \link{fluxmeasurements}
}
\examples{
## Example 1: Simple Generation of an aperture
#Generate a random grid radius
gw<-floor(runif(1)*100)
#Define a grid onto which we will place the aperture
grid<-expand.grid(seq(-gw,gw), seq(-gw,gw))
#Generate random elliptical aperture parameters
majax<-runif(1)*gw
axrat<-runif(1)
axang<-rnorm(1)*90
#Call the function without improving edge pixel values
aper_expanded<-iterapint(x=grid[,1],y=grid[,2],xstep=1,ystep=1,axrat=axrat,axang=axang,majax=majax, itersteps=0)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(gw*2+1))
#Plot Aperture
image(aper)


## Example 2: Improve aperture edge-pixel determination
#Using the same parameters as in Example 1, just improve edge determination
aper_expanded<-iterapint(x=grid[,1],y=grid[,2],xstep=1,ystep=1,axrat=axrat,axang=axang,majax=majax, upres=3, itersteps=4)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(gw*2+1))
#Plot Aperture
image(aper)

## Example 3: Quantifying improvement of aperture integral
#Generate the grid
grid<-expand.grid(seq(-2,2,by=0.1), seq(-2,2, by=0.1))
#Using a simple elliptical parameters, create basic aperture
aper_expanded<-iterapint(x=grid[,1],y=grid[,2],xstep=0.1,ystep=0.1,axrat=0.5,axang=-45,majax=2,itersteps=0)
#Convert return back into matrix
aper<-matrix(aper_expanded[,3],nrow=(5))
#Plot Aperture
image(aper)
#This aperture should integrate to 2pi, so we can use this to
#quantify the improvement of our integral by plotting the integral vs iteration
residual<-array(0,11)
for (i in 1:11) {
  aper_expanded<-iterapint(x=grid[,1],y=grid[,2],xstep=0.1,ystep=0.1,axrat=0.5,axang=-45,majax=2,upres=2,itersteps=(i-1),pixscale=TRUE)
  residual[i]=abs(sum(aper_expanded[,3])-2*pi)
}
#Plot the residuals
plot(x=seq(0,10), y=residual, xlab="Number of iterations", ylab="Residual",
main="Aperture Integral Residual with Increasing Edge Accuracy")
lines(x=seq(0,10), y=residual)

}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
%\keyword{ ~kwd1 }
%\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
